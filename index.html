<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Lacrosse Strategy Board</title>
  <style>
    body { font-family: Arial, sans-serif; margin: 20px; }
    #board { border: 1px solid black; background: #f9f9f9; cursor: pointer; display: block; }
    button { margin: 5px; padding: 8px 12px; font-size: 14px; }
    #controls { margin-bottom: 10px; }
  </style>
</head>
<body>
  <h2>Lacrosse Strategy Board</h2>

  <div id="controls">
    <button id="addBlue">Add Blue Player</button>
    <button id="addRed">Add Red Player</button>
    <button id="export">Export Play (JSON)</button>
    <button id="clear">Clear Play</button>
  </div>

  <canvas id="board" width="800" height="600"></canvas>

  <pre id="exportData" style="white-space: pre-wrap; background: #eee; padding: 10px; max-height: 150px; overflow-y: auto;"></pre>

  <!-- React and ReactDOM CDN -->
  <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>

  <script type="text/javascript">
    const { useState, useEffect, useRef } = React;

    const PLAYER_RADIUS = 15;
    const ARROW_HEAD_LENGTH = 10;

    function drawArrow(ctx, fromX, fromY, toX, toY) {
      const angle = Math.atan2(toY - fromY, toX - fromX);
      ctx.beginPath();
      ctx.moveTo(fromX, fromY);
      ctx.lineTo(toX, toY);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(toX, toY);
      ctx.lineTo(toX - ARROW_HEAD_LENGTH * Math.cos(angle - Math.PI / 6), toY - ARROW_HEAD_LENGTH * Math.sin(angle - Math.PI / 6));
      ctx.lineTo(toX - ARROW_HEAD_LENGTH * Math.cos(angle + Math.PI / 6), toY - ARROW_HEAD_LENGTH * Math.sin(angle + Math.PI / 6));
      ctx.lineTo(toX, toY);
      ctx.fill();
    }

    function LacrosseBoard() {
      const canvasRef = useRef(null);

      // Load saved play or start empty
      const [players, setPlayers] = useState(() => {
        const saved = localStorage.getItem("lacrossePlayers");
        return saved ? JSON.parse(saved) : [];
      });

      const [arrows, setArrows] = useState(() => {
        const saved = localStorage.getItem("lacrosseArrows");
        return saved ? JSON.parse(saved) : [];
      });

      const [draggingPlayerId, setDraggingPlayerId] = useState(null);
      const [draggingArrow, setDraggingArrow] = useState(null); // arrow being created
      const [hoveredPlayerId, setHoveredPlayerId] = useState(null);

      // Save to localStorage whenever players or arrows change
      useEffect(() => {
        localStorage.setItem("lacrossePlayers", JSON.stringify(players));
        localStorage.setItem("lacrosseArrows", JSON.stringify(arrows));
      }, [players, arrows]);

      // Draw everything
      useEffect(() => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw arrows
        ctx.strokeStyle = "black";
        ctx.fillStyle = "black";
        ctx.lineWidth = 2;
        arrows.forEach(({ fromId, toId }) => {
          const from = players.find(p => p.id === fromId);
          const to = players.find(p => p.id === toId);
          if (from && to) {
            drawArrow(ctx, from.x, from.y, to.x, to.y);
          }
        });

        // Draw players
        players.forEach(({ x, y, color, id }) => {
          ctx.beginPath();
          ctx.arc(x, y, PLAYER_RADIUS, 0, Math.PI * 2);
          ctx.fillStyle = color;
          ctx.fill();
          ctx.lineWidth = (id === hoveredPlayerId || id === draggingPlayerId) ? 4 : 1;
          ctx.strokeStyle = (id === hoveredPlayerId) ? "orange" : "black";
          ctx.stroke();

          // Draw player number
          ctx.fillStyle = "white";
          ctx.font = "bold 14px Arial";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText(id, x, y);
        });

        // If dragging arrow, draw the temp arrow
        if (draggingArrow) {
          const { fromId, toX, toY } = draggingArrow;
          const from = players.find(p => p.id === fromId);
          if (from) {
            ctx.strokeStyle = "gray";
            ctx.fillStyle = "gray";
            ctx.lineWidth = 2;
            drawArrow(ctx, from.x, from.y, toX, toY);
          }
        }
      }, [players, arrows, draggingPlayerId, draggingArrow, hoveredPlayerId]);

      // Helpers
      function getPlayerAtPosition(x, y) {
        return players.find(
          (p) => Math.hypot(p.x - x, p.y - y) < PLAYER_RADIUS
        );
      }

      // Mouse handlers
      function onMouseDown(e) {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        const player = getPlayerAtPosition(x, y);
        if (e.shiftKey && player) {
          // Start arrow drag from this player
          setDraggingArrow({ fromId: player.id, toX: x, toY: y });
          return;
        }
        if (player) {
          setDraggingPlayerId(player.id);
        }
      }

      function onMouseMove(e) {
        const rect = canvasRef.current.getBoundingClientRect();
        const x = e.clientX - rect.left;
        const y = e.clientY - rect.top;

        if (draggingPlayerId !== null) {
          setPlayers(players.map(p =>
            p.id === draggingPlayerId ? { ...p, x, y } : p
          ));
        } else if (draggingArrow) {
          setDraggingArrow({ ...draggingArrow, toX: x, toY: y });
        } else {
          // Highlight player on hover
          const hovered = getPlayerAtPosition(x, y);
          setHoveredPlayerId(hovered ? hovered.id : null);
        }
      }

      function onMouseUp(e) {
        if (draggingArrow) {
          const rect = canvasRef.current.getBoundingClientRect();
          const x = e.clientX - rect.left;
          const y = e.clientY - rect.top;
          const targetPlayer = getPlayerAtPosition(x, y);

          if (targetPlayer && targetPlayer.id !== draggingArrow.fromId) {
            // Add arrow connection
            setArrows([...arrows, { fromId: draggingArrow.fromId, toId: targetPlayer.id }]);
          }
          setDraggingArrow(null);
        }
        setDraggingPlayerId(null);
      }

      // UI handlers for buttons
      function addPlayer(color) {
        const newId = players.length > 0 ? Math.max(...players.map(p => p.id)) + 1 : 1;
        const newPlayer = { id: newId, x: 100, y: 100, color };
        setPlayers([...players, newPlayer]);
      }

      function clearPlay() {
        if (confirm("Are you sure you want to clear all players and arrows?")) {
          setPlayers([]);
          setArrows([]);
        }
      }

      function exportPlay() {
        const exportData = { players, arrows };
        const text = JSON.stringify(exportData, null, 2);
        document.getElementById("exportData").textContent = text;
      }

      return React.createElement(
        React.Fragment,
        null,
        React.createElement("canvas", {
          id: "board",
          ref: canvasRef,
          width: 800,
          height: 600,
          onMouseDown,
          onMouseMove,
          onMouseUp,
          onMouseLeave: onMouseUp,
        }),
        React.createElement("div", { style: { marginTop: 10 } },
          React.createElement("button", { onClick: () => addPlayer("blue") }, "Add Blue Player"),
          React.createElement("button", { onClick: () => addPlayer("red") }, "Add Red Player"),
          React.createElement("button", { onClick: exportPlay }, "Export Play (JSON)"),
          React.createElement("button", { onClick: clearPlay }, "Clear Play")
        ),
        React.createElement("pre", { id: "exportData", style: { whiteSpace: "pre-wrap", background: "#eee", padding: 10, maxHeight: 150, overflowY: "auto", marginTop: 10 } })
      );
    }

    const rootElem = document.getElementById("board").parentNode;
    ReactDOM.createRoot(rootElem).render(React.createElement(LacrosseBoard));
  </script>
</body>
</html>
